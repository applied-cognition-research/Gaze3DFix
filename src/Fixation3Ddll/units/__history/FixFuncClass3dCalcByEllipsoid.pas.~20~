//****************************************************************************************************************************************************
//****************************************************************************************************************************************************
//***
//***
//***       FixFuncClass3dCalcByEllipsoid -Dispersionsbasierte Erkennung dreidimensionaler Fixationen mit ellipsoiden Toleranzbereich
//***       =========================================================================================================================
//***
//***       Datum:            20.05.2016
//***       Entwickler:       Sascha Weber (sascha.weber@tu-dresden.de)
//***
//***
//***
//***       Implementierung:  Die dreidimensionale Fixationserkennung mit ellipsoiden Toleranzbereich wurde in Kooperation mit
//***                         Dixon Cleveland (LC-Technologies, Inc.) in die bislang zweidimensionale Logik der
//***                         Eyegaze Analysis System Fixationserkennung implementiert und auf die dritte Dimension erweitert.
//***
//***                         Original 2D-Fixationserkennung             File Name:       FIXFUNC.C
//***                                                                    Program Name:    Eye Fixation Analysis Functions
//***                                                                    Company:         LC Technologies, Inc.
//***                                                                                     10363 Democracy Lane
//***                                                                                     Fairfax, VA 22030
//***                                                                                     (703) 385-8800
//***                                                                    Date Created:    10/20/89
//***                                                                                     04/12/95 modified: turned into collection of functions
//***
//***
//***
//***       Beschreibung:     Dieser Funktion werden dreidimensionale Blickorte übergeben und anhand einstellbarer Parameter
//***                         geprüft, ob sich die 3D-Blickorte innerhalb eines ellipsoiden Toleranzberereich befinden. Liegt die
//***                         minimale Anzahl an Samples innerhalb der ellispoiden Fixationshülle, wird die Fixationshypothese bestätigt.
//***                         Mit jedem neuen Sample wird die Fixationshypothese erneut geprüft und bei Bestätigung das neue Sample der
//***                         bestehenden Fixation hinzugefügt. Die Rückgabewerte beinhalten u.a. die Parameter der dreidimensionalen Fixation.
//***                         Die detaillierte Beschreibung der Parameter und Algorithmen erfolgt an den entsprechenden Stellen im Source-Code.
//***
//***
//***




unit FixFuncClass3dCalcByEllipsoid;
interface
uses Windows, CodeSiteLogging;

type
  TFixFuncClass3dCalcByEllipsoid = class
  const
    RING_SIZE = 121;                    // *  size of the ring buffer, length of the delay line in DetectFixation ()
                                        // *  should be greater than iMinimumFixSamples

                                        // *  the 3 types of fixations tracked by the algorithm
    NEW_FIX = 0;			                  // *  new fixation
    PRES_FIX = 1;                       // *  present fixation
    PREV_FIX = 2;                       // *  previous fixation


  //**************************************************************************************************************************************************
  //* STRUCTURES DEFINITIONS:

  Type
    _stFix = record 			              // *  FIXATION DATA
      iStartCount: Integer; 		        // *  call count to DetectFixation() when the fixation started
      iEndCount: Integer; 		          // *  call count to DetectFixation() when the fixation ended

      iNEyeFoundSamples: Integer; 	    // *  number of eye-found gazepoint samples
                                        // *    collected so far in the fixation hypothesis
                                        // *    NOTE: If iNEyeFoundSamples is 0, the
                                        // *          fixation hypothesis does not exist,
                                        // *          i.e. there is no gazepoint data to
                                        // *          support an existence hypothesis for
                                        // *          the fixation.

      fXSum: Single; 			              // *  summations for calculation of average fixation position
      fYSum: Single;
      fZSum: Single;

      fX: Single;  	  		              // *  average coordinate of the eye fixation pooint (user selected units)
      fY: Single;
      fZ: Single;

      fXEllipsoidR: Single;             // *  parameters of the ellipsoid (position and orientation) in space
      fYEllipsoidR: Single;
      fZEllipsoidR: Single;
      fEllipsoidYaw: Single;
      fEllipsoidPitch: Single;

      bFixationVerified: Integer; 	    // *  flag indicating whether the fixation hypothesis has been verified
    end;

    _stRingBuf = record 		            // *  RING BUFFER STORING PAST GAZEPOINT AND FIXATION-STATE VALUES

      iDfCallCount: Integer; 		        // *  DetectFixation call-count at the time of the sample

      bGazeFound: Integer; 		          // *  gazepoint found flag

      fXGaze: Single; 			            // *  3D gazepoint coordinate
      fYGaze: Single;
      fZGaze: Single;

      fXFix: Single; 			              // *  current 3D fixation coordinate - includes the current gazepoint
      fYFix: Single;
      fZFix: Single;

      fXEllipsoidR: Single;             // *  current 3D ellipsoid coordinate
      fYEllipsoidR: Single;
      fZEllipsoidR: Single;
                                        // *  Euler's angle rotation in casrtesian coordinates
      fEllipsoidYaw: Single;            // *  yaw angle
      fEllipsoidPitch: Single;          // *  pitch angle

      iEyeMotionState: Integer; 	      // *  state of the eye motion: 1=MOVING, 2=FIXATING, 3=FIXATION_COMPLETED

      iSacDuration: Integer; 		        // *  saccade duration
      iFixDuration: Integer; 		        // *  fixation duration
    end;

  //**************************************************************************************************************************************************
  //*  GLOBAL FIXFUNC VARIABLES:

  private
    iDfCallCount: Integer;              // *  number of times the DetectFixation() function has been called since it was
                                        // *    initialized (depending on eyetracking sample rate)

    iNOutsidePresEllipsoid: Integer;    // *  number of successive gazepoint samples outside the present fixation's
                                        // *    acceptance ellipsoid

    bGazeInPresFix: Integer;            // *  is the current 3D gaze position inside the present fixation (1=in, 0=out)
    bGazeInNewFix:  Integer;            // *  is the current 3D gaze position in the new fixation (1=in, 0=out)

    iMaxMissedSamples: Integer;         // *  maximum number of successive gazepoint samples that may go untracked before
                                        // *    a fixation is allowed to continue

    iMaxOutSamples: Integer; 		        // *  maximum number of successive gazepoint samples that may go outside the
                                        // *    fixation acceptance ellipsoid

    stFix: array [0 .. 2] of _stFix;	  // *  prior, present and new fixations
                                        // *    NEW_FIX = 0
                                        // *    PRES_FIX = 1
                                        // *    PREV_FIX = 2

    stRingBuf: array [0 .. RING_SIZE] of _stRingBuf;

    iCurrentRingIndex: Integer;	        // *  ring index of the current gaze sample
    iRingIndexDelay: Integer;		        // *  ring index of the gaze sample taken iMinimumFixSamples ago
    siPreviousFixEndCount: Integer;     // *  end of the previous fixation

  protected
    procedure DeclarePresentFixationComplete(iMinimumFixSamples: Integer);
    procedure MoveNewFixToPresFix;
    procedure StartFixationHypothesisAtGazepoint(iNewPresOrPrev: Integer; fXGaze, fYGaze, fZGaze: Single);
    procedure TestPresentFixationHypothesis(iMinimumFixSamples: Integer);
    procedure TestPresFixHypAndUpdateRingBuffer(iMinimumFixSamples: Integer);
    procedure UpdateFixationHypothesis(iNewPresOrPrev: Integer;  fXLeftEye, fYLeftEye, fZLeftEye, fXRightEye, fYRightEye, fZRightEye, fXGaze, fYGaze, fZGaze, fAccuracyAngleRad: Single; iMinimumFixSamples: Integer);
    procedure ResetFixationHypothesis(iNewPresOrPrev: Integer);

    procedure CalcEllipsoid(fXEyeLeft, fYEyeLeft, fZEyeLeft, fXEyeRight, fYEyeRight, fZEyeRight, fXEllipsoidCenter, fYEllipsoidCenter, fZEllipsoidCenter, fAccuracyAngleRad: Single; var fXEllipsoidR, fYEllipsoidR, FZEllipsoidR, fEllipsoidYaw, fEllipsoidPitch: Single);
    function  IsGazeInFix(iNewPresOrPrev: Integer; fXEyeLeft, fYEyeLeft, fZEyeLeft, fXEyeRight, fYEyeRight, fZEyeRight: Single; fXGaze, fYGaze, fZGaze: Single; fAccuracyAngleRad: Single): Integer;


  public
    gb_stRingBuf: array [0 .. RING_SIZE] of _stRingBuf;
    gb_stFix: array [0 .. 2] of _stFix;


    procedure InitFixation(iMinimumFixSamplesInit, iMaxMissedSamplesInit, iMaxOutSamplesInit: Integer);

    function DetectFixation(  bValidSample: Integer;

                              fXLeftEye: Single;
                              fYLeftEye: Single;
                              fZLeftEye: Single;

                              fXRightEye: Single;
                              fYRightEye: Single;
                              fZRightEye: Single;

                        			fXGaze: Single;
      			                  fYGaze: Single;
                              fZGaze: Single;

                              fAccuracyAngleRad: Single;
                              iMinimumFixSamples: Integer;

                 out          pbValidSampleDelayed: Integer;

                 out          pfXGazeDelayed,
                              pfYGazeDelayed,
                              pfZGazeDelayed: Single;

                 out          pfXFixDelayed,
                              pfYFixDelayed,
                              pfZFixDelayed: Single;

                 out          pfXEllipsoidRDelayed,
                              pfYEllipsoidRDelayed,
                              pfZEllipsoidRDelayed: Single;

                 out          pfEllipsoidYawDelayed,
                              pfEllipsoidPitchDelayed: Single;

                 out          piSacDurationDelayed,
                              piFixDurationDelayed: Integer): Integer;
  end;
const

  MOVING = 0;
  FIXATING = 1;
  FIXATION_COMPLETED = 2;

implementation

uses
  SysUtils;

const
  FALSE = 0;
  TRUE = 1;



procedure TFixFuncClass3dCalcByEllipsoid.ResetFixationHypothesis(iNewPresOrPrev: Integer);
// * Zurücksetzen der NewPresPrev-Fixation (abhängig vom Übergabe-Argument)

begin
  stFix[iNewPresOrPrev].iStartCount := 0;
  stFix[iNewPresOrPrev].iEndCount := 0;
  stFix[iNewPresOrPrev].iNEyeFoundSamples := 0; // 0 = Fixations-Hypothese existiert nicht mehr.
  stFix[iNewPresOrPrev].fXSum := 0;
  stFix[iNewPresOrPrev].fYSum := 0;
  stFix[iNewPresOrPrev].fZSum := 0;
  stFix[iNewPresOrPrev].fX := 0;
  stFix[iNewPresOrPrev].fY := 0;
  stFix[iNewPresOrPrev].fZ := 0;
  stFix[iNewPresOrPrev].fXEllipsoidR := 0;
  stFix[iNewPresOrPrev].fYEllipsoidR := 0;
  stFix[iNewPresOrPrev].fXEllipsoidR := 0;
  stFix[iNewPresOrPrev].fEllipsoidYaw := 0;
  stFix[iNewPresOrPrev].fEllipsoidPitch := 0;
  stFix[iNewPresOrPrev].bFixationVerified := FALSE;

  // * Falls die PRES-Fixation zurückgesetzt wird, muss auch die Anzahl aufeinander folgender Blickort-Samples
  // * außerhalb des Fixations-Akzeptanz-Bereiches zurückgesetzt werden.
  if (iNewPresOrPrev = PRES_FIX) then
  begin
    iNOutsidePresEllipsoid := 0;
  end;
end;

function TFixFuncClass3dCalcByEllipsoid.IsGazeInFix(iNewPresOrPrev: Integer; fXEyeLeft, fYEyeLeft, fZEyeLeft, fXEyeRight, fYEyeRight, fZEyeRight: Single; fXGaze, fYGaze, fZGaze: Single; fAccuracyAngleRad: Single): Integer;
// * Berechnung des Abstandes des Blickortes zum NewPresPrev-Fixationsort

var
    XEyeLeft,YEyeLeft,ZEyeLeft: Single;             // left eye position
    XEyeRight,YEyeRight,ZEyeRight: Single;          // right eye position
    XGaze,YGaze,ZGaze: Single;                      // gaze
    XFix,YFix,ZFix: Single;                         // fixation

    Alpha:    Single;                               // angle of accuracy in radians

    Psi, Theta: Single;                             // yaw and pitch angle between cyclops eye and current fixation

    deltaX,deltaY,deltaZ: Single;                   // deviation before ellipsoid rotation
    deltaXprime,deltaYprime,deltaZprime: Single;    // deviation after ellipsoid rotation

    XEllipsoidR,YEllipsoidR,ZEllipsoidR: Single;    // ellipsoid dimensions

    InEllipsoid: Single;                            // <=1 inside  the ellipsoid
                                                    // >1 outside the ellipsoid

begin
  // left Eye
  XEyeLeft:=fXEyeLeft;
  YEyeLeft:=fYEyeLeft;
  ZEyeLeft:=fZEyeLeft;

  // right Eye
  XEyeRight:=fXEyeRight;
  YEyeRight:=fYEyeRight;
  ZEyeRight:=fZEyeRight;

  // gaze
  XGaze:=fXGaze;
  YGaze:=fYGaze;
  ZGaze:=fZGaze;

  // accuracy angle
  Alpha:=fAccuracyAngleRad;
  //Alpha:=fAccuracyAngleRad/57.3;

  // fixation
  XFix := stFix[iNewPresOrPrev].fX;
  YFix := stFix[iNewPresOrPrev].fY;
  ZFix := stFix[iNewPresOrPrev].fZ;

  // deviations before rotation
  deltaX:=XGaze-XFix;
  deltaY:=YGaze-YFix;
  deltaZ:=ZGaze-ZFix;

  CalcEllipsoid(XEyeLeft,YEyeLeft,ZEyeLeft,XEyeRight,YEyeRight,ZEyeRight,XFix,YFix,ZFix,Alpha,XEllipsoidR,YEllipsoidR,ZEllipsoidR,Psi,Theta);

  // deviations after rotation
  deltaXprime:=deltaX*cos(Psi)+deltaZ*sin(Psi);
  deltaYprime:=deltaY*cos(Theta)+deltaZ*sin(Theta);
  deltaZprime:=deltaZ*cos(Theta)*cos(Psi)-deltaX*sin(Psi)-deltaY*sin(Theta);

  // Check if gaze is in ellipsoid
  InEllipsoid:=sqr(deltaXprime/XEllipsoidR)+sqr(deltaYprime/YEllipsoidR)+sqr(deltaZprime/ZEllipsoidR);

  if InEllipsoid<=1 then
    Result:=true
  else
    Result:=false;

end;



procedure TFixFuncClass3dCalcByEllipsoid.TestPresFixHypAndUpdateRingBuffer(iMinimumFixSamples: Integer);
// * Jedes Mal, wenn ein Blickort zur jetzigen Fixations-Hypothese hinzugefügt wird, prüft die Funktion, ob die
// * Fixations-Hypothese bestätigt werden kann. Falls ja, updatet diese Funktion den Ringpuffer mit den entsprechenden Werten.

// * Zur Erinnerung: Der iEyeMoving-Wert im aktuellen Ringpuffer Index wurde mit MOVING initialisiert, zu
// * Beginn mit dem Aufruf der Funktion: DetectFixation()

var
  iRingPointOffset: Integer; 			  // * Ring-Index-Offset in Bezug auf den aktuellen Ring-Index
  iDumRingIndex: Integer; 			    // * Dummy Ring-Index
  iNFixSamples: Integer; 			      // * Anzahl der Samples innerhalb der Fixation bis jetzt
  iNNewSamples: Integer; 			      // * Anzahl neu hinzuzufügender Samples zur Ringpuffer Fixation

begin

  // * Falls die gegenwärtige Fixations-Hypothese noch nicht überprüft wurde, prüfe die Hypothese jetzt.
  if (stFix[PRES_FIX].bFixationVerified = FALSE) then
  begin

    // * Falls genügend Samples zur Erkennung einer gültigen Fixation vorliegen 
    if (stFix[PRES_FIX].iNEyeFoundSamples >= iMinimumFixSamples) then
    begin
      // * Deklrariere die gegenwärtige Fixation als bestätigt.
      stFix[PRES_FIX].bFixationVerified := TRUE;

      // * Markiere die Fixation innerhalb des Ringpuffers:
      // * Füge alle Samples in den Ringpuffer ein, vom Start bis zum Endpunkt der PRES_Fixation:
      // * Berechne die Anzahl der Samples in der aktuellen Fixation, inklusive der guten Samples, der no-track Samples
      // * und auch der out Samples, die in die Fixation aufgenommen werden sollen.
      // * Beachte: +1 zur Berücksichtigung der beiden Start- und End-Samples.

      iNFixSamples := stFix[PRES_FIX].iEndCount - stFix[PRES_FIX].iStartCount + 1;

      // * Stelle sicher, dass die Anzahl der Samples nicht die Ringpuffer-Größe überschreitet.
      Assert(iNFixSamples > 0);
      Assert(iNFixSamples <= RING_SIZE);
      if (iNFixSamples > RING_SIZE) then
        iNFixSamples := RING_SIZE;

      // * Gehe rückwärts durch den Ringpuffer, beginnend mit dem aktuellen Ringindex, um die Anzahl der Fixations-
      // * Samples.
      for iRingPointOffset := 0 to iNFixSamples - 1 do
      begin
        // * Berechne den nächsten Ringindex (rückwärts).
        iDumRingIndex := iCurrentRingIndex - iRingPointOffset;
        if (iDumRingIndex < 0) then
          Inc(iDumRingIndex, RING_SIZE);
        Assert((iDumRingIndex >= 0) and (iDumRingIndex < RING_SIZE));

        // * Deklariere das Sample als FIXATING am aktuellen Fixationsort.
        stRingBuf[iDumRingIndex].iEyeMotionState := FIXATING;
        stRingBuf[iDumRingIndex].fXFix := stFix[PRES_FIX].fX;
        stRingBuf[iDumRingIndex].fYFix := stFix[PRES_FIX].fY;
        stRingBuf[iDumRingIndex].fZFix := stFix[PRES_FIX].fZ;

        stRingBuf[iDumRingIndex].fXEllipsoidR := stFix[PRES_FIX].fXEllipsoidR;
        stRingBuf[iDumRingIndex].fYEllipsoidR := stFix[PRES_FIX].fYEllipsoidR;
        stRingBuf[iDumRingIndex].fZEllipsoidR := stFix[PRES_FIX].fZEllipsoidR;
        stRingBuf[iDumRingIndex].fEllipsoidYaw := stFix[PRES_FIX].fEllipsoidYaw;
        stRingBuf[iDumRingIndex].fEllipsoidPitch := stFix[PRES_FIX].fEllipsoidPitch;

        // * Setze den Ringpuffer-Eintrag für die Sakkadendauer, z.B. die Zeit zwischen Ende der
        // * letzten Fixation bis zum Start der gegenwärtigen Fixation.
        // * Beachte: Die Sakkadendauer ist bei allen Samples dieser Fixation die gleiche.
        stRingBuf[iDumRingIndex].iSacDuration := stFix[PRES_FIX].iStartCount - stFix[PREV_FIX].iEndCount - 1;

        // * Setze den Ringpuffer-Eintrag für die Fixationsdauer, z.B. die Zeit zwischen
        // * Start der gegenwärtigen Fixation und Zeit des Ringindexes.
        // * Beachte: Die Fixationsdauer ändert sich! -> nimmt für frühere gespeicherte Punkte ab

        stRingBuf[iDumRingIndex].iFixDuration := stFix[PRES_FIX].iEndCount - iRingPointOffset - stFix[PRES_FIX].iStartCount + 1;
      end;

      // * Speichere das Fixationsende (Zahl) für den nächsten Aufruf dieser Funktion.
      siPreviousFixEndCount := stFix[PRES_FIX].iEndCount;
    end

    // * Andererseits, wenn es nicht genügend gute Augensamples für die Erkennung einer Fixation gibt, 
    else // if (stFix[PRES_FIX].iNEyeFoundSamples < iMinimumFixSamples)
    begin
      // *  lasse den Ringpuffer unverändert.
    end
  end

  // * Andernerseits, falls die gegenwärtige Fixationshypothese vorher bestätigt wurde 
  else 	// if (stFix[PRES_FIX].bFixationVerified == TRUE)
  begin
    // * Erweitere die Fixation innerhalb des Ringpuffers:
    // * Markiere alle neuen Samples im Ringpuffer ab dem letzten guten Sample, inklusive aller missed
    // * oder out Punkte als 'fixierend' bzw. FIXATING.
    // * Berechne die Anzahl neuer Samples seit  dem letzten guten Sample der aktuellen Fixation
    iNNewSamples := iDfCallCount - siPreviousFixEndCount;

    // * Stelle sicher, dass die Anzahl der Samples nicht die Ringpuffergröße übersteigt.
    Assert(iNNewSamples > 0);
    Assert(iNNewSamples <= RING_SIZE);
    if (iNNewSamples > RING_SIZE) then
      iNNewSamples := RING_SIZE;

     // * Gehe rückwärts durch den Ringpuffer, beginnend mit dem aktuellen Ringindex, um die Anzahl der Fixations-
     // * Samples.
    for iRingPointOffset := 0 to iNNewSamples - 1 do
    begin
      // * Berechne den nächsten Ringindex (rückwärts).
      iDumRingIndex := iCurrentRingIndex - iRingPointOffset;
      if (iDumRingIndex < 0) then
        Inc(iDumRingIndex, RING_SIZE);

      Assert((iDumRingIndex >= 0) and (iDumRingIndex < RING_SIZE));

      // * Deklariere das Sample als FIXATING am aktuellen Fixationsort.
      stRingBuf[iDumRingIndex].iEyeMotionState := FIXATING;
      stRingBuf[iDumRingIndex].fXFix := stFix[PRES_FIX].fX;
      stRingBuf[iDumRingIndex].fYFix := stFix[PRES_FIX].fY;
      stRingBuf[iDumRingIndex].fZFix := stFix[PRES_FIX].fZ;
      stRingBuf[iDumRingIndex].fXEllipsoidR := stFix[PRES_FIX].fXEllipsoidR;

      stRingBuf[iDumRingIndex].fYEllipsoidR := stFix[PRES_FIX].fYEllipsoidR;
      stRingBuf[iDumRingIndex].fZEllipsoidR := stFix[PRES_FIX].fZEllipsoidR;
      stRingBuf[iDumRingIndex].fEllipsoidYaw := stFix[PRES_FIX].fEllipsoidYaw;
      stRingBuf[iDumRingIndex].fEllipsoidPitch := stFix[PRES_FIX].fEllipsoidPitch;

      // * Setze den Ringpuffer-Eintrag für die Sakkadendauer, z.B. die Zeit zwischen Ende der
      // * letzten Fixation bis zum Start der gegenwärtigen Fixation.
      // * Beachte: Die Sakkadendauer ist bei allen Samples dieser Fixation die gleiche.
      stRingBuf[iDumRingIndex].iSacDuration := stFix[PRES_FIX].iStartCount - stFix[PREV_FIX].iEndCount - 1;

      // * Setze den Ringpuffer-Eintrag für die Fixationsdauer, z.B. die Zeit zwischen
      // * Start der gegenwärtigen Fixation und Zeit des Ringindexes.
      // * Beachte: Die Fixationsdauer ändert sich! -> nimmt für frühere gespeicherte Punkte ab
      stRingBuf[iDumRingIndex].iFixDuration := stFix[PRES_FIX].iEndCount - iRingPointOffset - stFix[PRES_FIX].iStartCount + 1;
    end;

    // * Speichere das Fixationsende (Zahl) für den nächsten Aufruf dieser Funktion.
    siPreviousFixEndCount := stFix[PRES_FIX].iEndCount;
  end;
end;



procedure TFixFuncClass3dCalcByEllipsoid.UpdateFixationHypothesis(iNewPresOrPrev: Integer;  fXLeftEye, fYLeftEye, fZLeftEye, fXRightEye, fYRightEye, fZRightEye, fXGaze, fYGaze, fZGaze, fAccuracyAngleRad: Single; iMinimumFixSamples: Integer);
// * Diese Funktion erweitert die iNewPresOrPrev-Fixation um einen neuen Blickort -> beides Übergabeparameter
// * und prüft, ob genug Samples vorhanden sind, um zu erkennen, dass das Auge in diesem Moment fixiert.
// * Falls dem so ist, deklariere die betreffenden Ringpuffereinträge als zur Fixation zugehörig.
// * Die Funktion stellt auch sicher, dass es keine Hypothese für eine neue Fixation gibt.

begin
  // * Erweiterung der Fixation um den neuen Blickpunkt.
  Inc(stFix[iNewPresOrPrev].iNEyeFoundSamples);
  stFix[iNewPresOrPrev].fXSum := stFix[iNewPresOrPrev].fXSum + fXGaze;
  stFix[iNewPresOrPrev].fYSum := stFix[iNewPresOrPrev].fYSum + fYGaze;
  stFix[iNewPresOrPrev].fZSum := stFix[iNewPresOrPrev].fZSum + fZGaze;
  stFix[iNewPresOrPrev].fX := stFix[iNewPresOrPrev].fXSum / stFix[iNewPresOrPrev].iNEyeFoundSamples;
  stFix[iNewPresOrPrev].fY := stFix[iNewPresOrPrev].fYSum / stFix[iNewPresOrPrev].iNEyeFoundSamples;
  stFix[iNewPresOrPrev].fZ := stFix[iNewPresOrPrev].fZSum / stFix[iNewPresOrPrev].iNEyeFoundSamples;
  stFix[iNewPresOrPrev].iEndCount := iDfCallCount;


  // * Berechnung der neuen Ellipsoidenparameter
  CalcEllipsoid(fXLeftEye,fYLeftEye, fZLeftEye, fXRightEye, fYRightEye, fZRightEye,stFix[iNewPresOrPrev].fX, stFix[iNewPresOrPrev].fY, stFix[iNewPresOrPrev].fZ, fAccuracyAngleRad, stFix[iNewPresOrPrev].fXEllipsoidR, stFix[iNewPresOrPrev].fYEllipsoidR, stFix[iNewPresOrPrev].fZEllipsoidR, stFix[iNewPresOrPrev].fEllipsoidYaw, stFix[iNewPresOrPrev].fEllipsoidPitch);

  // * Falls es sich um die gegenwärtige Fixation handelt, 
  if (iNewPresOrPrev = PRES_FIX) then
  begin

    // *  lösche die Anzahl aufeinanderfolgender Blickpunkte, die außerhalb des aktuellen
    // * Fixations-Akzeptanzbereiches lagen.
    iNOutsidePresEllipsoid := 0;

    // * Teste, ob es genug Samples in der gegenwärtigen Fixations-Hypothese zur Erkennung einer Fixation gibt.
    // * Falls dem so ist, deklariere die betreffenden Ringpuffereinträge als zur Fixation zugehörig.
    TestPresFixHypAndUpdateRingBuffer(iMinimumFixSamples);

    // * Stelle sicher, dass es keine Hypothese für eine neue Fixation gibt.
    ResetFixationHypothesis(NEW_FIX);

  end;
end;


procedure TFixFuncClass3dCalcByEllipsoid.StartFixationHypothesisAtGazepoint(iNewPresOrPrev: Integer; fXGaze, fYGaze, fZGaze: Single);
// * Diese Funktion startet die Fixation (NewPresPrev) am Blickort (beides Übergabewerte) und stellt sicher,
// * dass es keine neue Fixations-Hypothese gibt.

begin
  // * Starte die Fixation am Blickort.
  stFix[iNewPresOrPrev].iNEyeFoundSamples := 1;
  stFix[iNewPresOrPrev].fXSum := fXGaze;
  stFix[iNewPresOrPrev].fYSum := fYGaze;
  stFix[iNewPresOrPrev].fZSum := fZGaze;
  stFix[iNewPresOrPrev].fX := fXGaze;
  stFix[iNewPresOrPrev].fY := fYGaze;
  stFix[iNewPresOrPrev].fZ := fZGaze;

  stFix[iNewPresOrPrev].fXEllipsoidR := 0;
  stFix[iNewPresOrPrev].fYEllipsoidR := 0;
  stFix[iNewPresOrPrev].fZEllipsoidR := 0;

  stFix[iNewPresOrPrev].fEllipsoidYaw := 0;
  stFix[iNewPresOrPrev].fEllipsoidPitch := 0;

  stFix[iNewPresOrPrev].iStartCount := iDfCallCount;
  stFix[iNewPresOrPrev].iEndCount := iDfCallCount;
  stFix[iNewPresOrPrev].bFixationVerified := FALSE;

  // * Falls es sich um die gegenwärtige Fixation handelt 
  if (iNewPresOrPrev = PRES_FIX) then
  begin
    // *  lösche die Anzahl aufeinanderfolgender Blickpunkte, die außerhalb des aktuellen
    // * Fixations-Akzeptanzbereiches lagen.
    iNOutsidePresEllipsoid := 0;

    // *    Stelle sicher, dass es keine Hypothese für eine neue Fixation gibt.
    ResetFixationHypothesis(NEW_FIX);
  end;
end;



procedure TFixFuncClass3dCalcByEllipsoid.MoveNewFixToPresFix;
// * Diese Funktion kopiert die neuen Fixationsdaten in die gegenwärtige Fixation und löscht die neue Fixations-Hypothese

begin
   // * Lösche die Anzahl aufeinanderfolgender Blickpunkte, die außerhalb des aktuellen
   // * Fixations-Akzeptanzbereiches liegen.
   iNOutsidePresEllipsoid := 0;

   // * Erklärt die neue Fixations-Hypothese zur gegenwärtigen Fixations-Hypothese.
   stFix[PRES_FIX] := stFix[NEW_FIX];

   // * Löscht NEW_FIX.
   ResetFixationHypothesis(NEW_FIX);
end;


procedure TFixFuncClass3dCalcByEllipsoid.CalcEllipsoid(fXEyeLeft, fYEyeLeft,
  fZEyeLeft, fXEyeRight, fYEyeRight, fZEyeRight, fXEllipsoidCenter, fYEllipsoidCenter, fZEllipsoidCenter,
  fAccuracyAngleRad: Single; var fXEllipsoidR, fYEllipsoidR, FZEllipsoidR, fEllipsoidYaw, fEllipsoidPitch: Single);

var
    XCycl,YCycl,ZCycl: Single;    // Zyklopenauge

    D: Single;                    // Augenabstand
    R: Single;                    // Entfernung zwischen Zyklopenauge und aktueller Fixation

begin
   // Position des Zyklopenauges
  XCycl:=round((fXEyeLeft+fXEyeRight)/2);
  YCycl:=round((fYEyeLeft+fYEyeRight)/2);
  ZCycl:=round((fZEyeLeft+fZEyeRight)/2);

  D:=round(sqrt(sqr(fXEyeLeft-fXEyeRight)+sqr(fYEyeLeft-fYEyeRight)+sqr(fZEyeLeft-fZEyeRight)));

  R:=round(sqrt(sqr(XCycl-fXEllipsoidCenter)+sqr(YCycl-fYEllipsoidCenter)+sqr(ZCycl-fZEllipsoidCenter)));


  // Parameter der Ellipsoiden Fixationshülle
  fXEllipsoidR:=R*fAccuracyAngleRad;
  fYEllipsoidR:=R*fAccuracyAngleRad;
  FZEllipsoidR:=fXEllipsoidR*(R/D);

  fEllipsoidYaw:=+arctan((fXEllipsoidCenter-XCycl)/(fZEllipsoidCenter-ZCycl));      // Gierwinkel (yaw angle), psi ist positiv ausgerichtet falls sich
                                                                                    // die Fixation rechts vom Zyklopenauge befindet

  fEllipsoidPitch:=-arctan((fYEllipsoidCenter-YCycl)/(fZEllipsoidCenter-ZCycl));    // Neigungswinkel (pitch angle), theta ist positiv ausgerichtet
                                                                                    // falls sich die Fixation oberhalb des Zyklopenauges befindet

end;

procedure TFixFuncClass3dCalcByEllipsoid.DeclarePresentFixationComplete(iMinimumFixSamples:Integer);
// * Diese Funktion:
// * 	a) erklärt die aktuelle Fixation für beendet bei stFix[PRES_FIX].iEndCount.
// * 	b) erklärt die gegenwärtige Fixation zur vorhergehenden Fixation und
// * 	c) erklärt die neue Fixation, falls vorhanden zur gegenwärtigen Fixation.

var
  iRingIndexLastFixSample:Integer;	//* Ringindex des letzten Samples der gegenwärtigen kompletten Fixation
  iDoneNSamplesAgo:Integer;

begin
   //* Berechne wie viele Samples vorher die Fixation beendet war.
   iDoneNSamplesAgo := iDFCallCount - stFix[PRES_FIX].iEndCount;

   Assert(iDoneNSamplesAgo <= iMinimumFixSamples);
   if (iDoneNSamplesAgo > iMinimumFixSamples) then
       iDoneNSamplesAgo := iMinimumFixSamples;

   //* Berechne den Ringindex, der korrespondierend mit der zugehörigen Fertigstellungszeit der Fixation.
   iRingIndexLastFixSample := iCurrentRingIndex - iDoneNSamplesAgo;
   if (iRingIndexLastFixSample < 0) then
       Inc(iRingIndexLastFixSample, RING_SIZE);

   Assert(iRingIndexLastFixSample >= 0);
   Assert(iRingIndexLastFixSample < RING_SIZE);

   //*  Erkläre die gegenwärtige Fixation für beendet.
   stRingBuf[iRingIndexLastFixSample].iEyeMotionState := FIXATION_COMPLETED;

   //* Erkläre die gegenwärtige Fixation zur vorhergehenden Fixation
   stFix[PREV_FIX] := stFix[PRES_FIX];

   //* Erkläre die Daten der neuen Fixation, falls vorhanden, zur gegenwärtigen Fixation, lösche die neue Fixation
   //* und prüfe, ob es genug Samples in der neuen Fixation (jetzt die gegenwärtige) gibt, um zu prüfen, ob das Auge
   //* aktuell fixiert.
   MoveNewFixToPresFix();
end;


procedure TFixFuncClass3dCalcByEllipsoid.InitFixation(iMinimumFixSamplesInit, iMaxMissedSamplesInit, iMaxOutSamplesInit: Integer);
  // *  iMinimumFixSamples = minimum number of gaze samples that can be considered a fixation
  // *  Note: if the input value is less than 3, the function sets it to 3
  // *
  // *  This function clears the previous, present and new fixation hypotheses,
  // *  and it initializes DetectFixation()'s internal ring buffers of prior
  // *  gazepoint data.  InitFixation() should be called prior to a sequence
  // *  of calls to DetectFixation().
  // *

begin
  // *  Set the maximum allowable number of consecutive samples that may go
  // *  untracked within a fixation.
  iMaxMissedSamples := iMaxMissedSamplesInit;   // original: iMaxMissedSamples := 3;

  // *  Set the maximum allowable number of consecutive samples that may go
  // *  outside the fixation acceptance ellipsoid.
  iMaxOutSamples := iMaxOutSamplesInit;         // original: iMaxOutSamples := 1;

  // *  Initialize the internal ring buffer.
  iCurrentRingIndex := 0;
  while iCurrentRingIndex < RING_SIZE do

  begin
    stRingBuf[iCurrentRingIndex].iDfCallCount := 0;
    stRingBuf[iCurrentRingIndex].bGazeFound := FALSE;

    stRingBuf[iCurrentRingIndex].fXGaze := 0;
    stRingBuf[iCurrentRingIndex].fYGaze := 0;
    stRingBuf[iCurrentRingIndex].fZGaze := 0;

    stRingBuf[iCurrentRingIndex].fXFix := 0;
    stRingBuf[iCurrentRingIndex].fYFix := 0;
    stRingBuf[iCurrentRingIndex].fZFix := 0;

    stRingBuf[iCurrentRingIndex].fXEllipsoidR := 0;
    stRingBuf[iCurrentRingIndex].fYEllipsoidR := 0;
    stRingBuf[iCurrentRingIndex].fZEllipsoidR := 0;

    stRingBuf[iCurrentRingIndex].fEllipsoidYaw := 0;
    stRingBuf[iCurrentRingIndex].fEllipsoidPitch := 0;

    stRingBuf[iCurrentRingIndex].iEyeMotionState := MOVING;
    stRingBuf[iCurrentRingIndex].iSacDuration := 0;
    stRingBuf[iCurrentRingIndex].iFixDuration := 0;
    Inc(iCurrentRingIndex);
  end;
  iCurrentRingIndex := 0;
  iRingIndexDelay := RING_SIZE - iMinimumFixSamplesInit;

  // *  Set the number of times the DetectFixation() has been called since
  // *  initialization to zero, and initialize the previous fixation end count
  // *  so the first saccade duration will be a legitimate count.
  iDfCallCount := 0;
  stFix[PREV_FIX].iEndCount := 0;

  // *  Reset the present fixation data.
  ResetFixationHypothesis(PRES_FIX);

  // *  Reset the new fixation data.
  ResetFixationHypothesis(NEW_FIX);
end;



function TFixFuncClass3dCalcByEllipsoid.DetectFixation(

                                          // *  INPUT PARAMETERs:

                                          bValidSample: Integer; 		          // *  flag indicating whether or not the image processing algorithm
                                                                              // *    detected booth eyes and computed a valid 3d gazepoint (TRUE/FALSE)

                                          fXLeftEye: Single;                  // *  3D coordinates of the left eye
                                          fYLeftEye: Single;
                                          fZLeftEye: Single;

                                          fXRightEye: Single;                 // *  3D coordinates of the right eye
                                          fYRightEye: Single;
                                          fZRightEye: Single;

                                          fXGaze: Single; 				            // *  3D coordinates of the current gazepoint
                                          fYGaze: Single;
                                          fZGaze: Single;                                                                                                                                                                                                  fAccuracyAngleRad: Single;          // *  Schwellwert für die Berechnung der ellipsoiden Fixationshülle

                                          iMinimumFixSamples: Integer; 		    // *  minimum number of gaze samples that can be considered a fixation
                                                                              // *    Note: if the input value is less than 3, the function sets it to 3

                                          // * OUTPUT PARAMETERS: delayed gazepoint data with 3D fixation annotations:

                           out            pbValidSampleDelayed: Integer;      // *  bValidSample, iMinimumFixSamples ago

                           out            pfXGazeDelayed,  		                // *  3D coordinates of gazepoint, iMinimumFixSamples ago
                                          pfYGazeDelayed,
                                          pfZGazeDelayed: Single;

                           out            pfXFixDelayed, 			                // *  3D coordinates of fixation point, iMinimumFixSamples ago
                                          pfYFixDelayed,
                                          pfZFixDelayed: Single;

                           out            pfXEllipsoidRDelayed,               // *  3D coordinaties and orientation of the ellipsoid, iMinimumFixSamples ago
                                          pfYEllipsoidRDelayed,
                                          pfZEllipsoidRDelayed: Single;

                           out            pfEllipsoidYawDelayed,              // *    yaw angle
                                          pfEllipsoidPitchDelayed: Single;    // *    pitch angle

                           out            piSacDurationDelayed, 	            // *  duration of the saccade preceeding the preset fixation (samples)
                                          piFixDurationDelayed: Integer): Integer; 	// *  duration of the present fixation (samples)



// *  RETURN VALUES - Eye Motion State:
// *
// *    MOVING               0   The eye was in motion, iMinimumFixSamples ago.
// *    FIXATING             1   The eye was fixating, iMinimumFixSamples ago.
// *    FIXATION_COMPLETED   2   A completed fixation has just been detected, iMinimumFixSamples ago. With respect to the sample that reports
// *                               FIXATION_COMPLETED, the fixation started (iMinimumFixSamples + *piSaccadeDurationDelayed) ago and ended
// *                               iMinimumFixSamples ago.
// *
// *  SUMMARY
// *
// *    This function converts a series of uniformly-sampled (raw) gaze points into a series of variable-duration saccades and fixations.
// *    Fixation analysis may be performed in real time or after the fact.  To allow eye fixation analysis during real-time eyegaze data collection,
// *    the function is designed to be called once per sample.
// *
// *    When the eye is in motion, ie during saccades, the function returns 0 (MOVING).
// *
// *    When the eye is still, ie during fixations, the function returns 1 (FIXATING).
// *
// *    Upon the detected completion of a fixation, the function returns 2 (FIXATION_COMPLETED) and produces:
// *      a) the time duration of the saccade between the last and present eye fixation (eyegaze samples)
// *      b) the time duration of the present, just completed fixation (eyegaze samples)
// *      c) the average x, y and z coordinates of the eye fixation (in user defined units)
// *
// *    Note: Although this function is intended to work in "real time", there is a delay of iMinimumFixSamples in the filter which detects the
// *    motion/fixation condition of the eye.
// *
// *
// *  PRINCIPLE OF OPERATION
// *
// *    This function detects fixations by looking for sequences of gazepoint measurements that remain relatively constant. If a new gazepoint
// *    lies within a ellipsoid region around the running average of an on-going fixation, the fixation is extended to include the new gazepoint.
// *    The dimensions of the acceptance ellipsoid is user specified by setting the value of the function argument fAccuracyAngleRad. This angle
// *    defines the horizontal and vertical radius of the ellipsoid and the depth parameter is calculated related to the fixation distance (for
// *    further information see the comments on the CalcEllipsoid function.) The Ellipsoid is not radially symmetric and has to be oriented (yaw
// *    and pitch) to the user. Therefore a cyclopedian eye is defined between the users right and the left eye.
// *
// *    To accommodate noisy eyegaze measurements, a gazepoint that exceeds the deviation threshold is included in an on-going fixation if the
// *    subsequent gazepoint returns to a position within the threshold.
// *
// *    If a gazepoint is not found, during a blink for example, a fixation is extended if
// *      a) the next legitimate gazepoint measurement falls within the acceptance ellipsoid, and
// *      b) there are less than iMinimumFixSamples of successive missed gazepoints.  Otherwise, the previous fixation is considered to end at
// *         the last good gazepoint measurement.
// *
// *
// *  UNITS OF MEASURE
// *
// *    The gaze position/direction may be expressed in any units (e.g. millimeters, pixels, or radians), but the filter threshold must be
// *    expressed in the same units.
// *
// *  INITIALIZING THE FUNCTION
// *
// *    Prior to analyzing a sequence of gazepoint data, the InitFixation function should be called to clear any previous, present and new
// *    fixations and to initialize the ring buffers of prior gazepoint data.
// *
// *  PROGRAM NOTES
// *
// *    For purposes of describing an ongoing sequence of fixations, fixations in this program are referred to as "previous", "present", and "new".
// *    The present fixation is the one that is going on right now, or, if a new fixation has just started, the present fixation is the one that
// *    just finished.  The previous fixation is the one immediatly preceeding the present one, and a new fixation is the one immediately following
// *    the present one.  Once the present fixation is declared to be completed, the present fixation becomes the previous one, the new fixation
// *    becomes the present one, and there is not yet a new fixation.


// *  Rückgabewerte - Eye Motion State:
// *
// *    MOVING			          0   Das Auge war in Bewegung, iMinimumFixSamples vorher.
// *    FIXATING			        1   Das Auge fixierte, iMinimumFixSamples vorher.
// *    FIXATION_COMPLETED   	2   Eine abgeschlossene Fixation wurde erkannt, iMinimumFixSamples vorher.
// *
// *	In Bezug auf das Sample, welches FIXATION_COMPLETED zurück gibt, startete die Fixation
// *	(iMinimumFixSamples + *piSaccadeDurationDelayed) vorher und endete iMinimumFixSamples vorher.
// *
// *	Beachte:  Dadurch, dass es eine Mess-Verzögerung anhand der Bildverarbeitungsprozesse gibt (ca. 2-Samples),
// *            müssen die Start- und Endzeit in Bezug zur Echtzeit korrigiert werden.
// *
// *	Startzeit:  iMinimumFixSamples + *piSaccadeDurationDelayed + 2
// *	Endzeit: 	  iMinimumFixSamples + 2
// *
// *
// *  Zusammenfassung
// *  ===============
// *
// *  Diese Funktion konvertiert eine Serie gleichmäßig abgetasteter Blickpunkte in eine Serie von Sakkaden und Fixationen
// *  variabler Dauer.
// *
// *  Die Fixationserkennung kann in Echtzeit oder auch nachträglich erfolgen. Um die Fixationserkennung während der
// *  Blickdatenaufzeichnung (Echtzeit) durchführen zu können, muss diese Funktion für jedes Sample aufgerufen werden.
// *
// *  Falls das Auge in Bewegung ist, z.B. während einer Sakkade, gibt diese Funktion 0 (MOVING) zurück.
// *  Falls das Auge stillsteht, z.B. während einer Fixation gibt die Funktion 1 (FIXATING)  zurück.
// *  Falls eine abgeschlossene Fixation erkannt wird, gibt die Funktion 2 (FIXATION_COMPLETED) mit folgenden
// *  Parametern zurück:
// *
// *  	a) Die Sakkadendauer zwischen der letzten und gegenwärtigen Fixation (eyegaze samples)
// *  	b) Die Dauer der gegenwärtigen, jetzt abgeschlossenen Fixation
// *  	c) Die durchschnittlichen x- und y- Koordinaten der Fixation
// *
// *  Beachte: Obwohl diese Funktion  in Echtzeit arbeitet, gibt es eine Verzögerung von iMinimumFixSamples im Filter,
// *  welcher die Bewegung/Fixation des Auges erkennt.
// *
// *
// *  PRINZIP DES 3D-ALGORITHMUS
// *  ==========================
// *
// *  Diese Funktion erkennt Fixationen mittels Suche nach Sequenzen gemessener Blickorte, die relativ konstant sind bzw.
// *  am selben Ort verharren. Falls ein neu gemessener Blickort innerhalb eines Ellipsoiden um das Zentrum der
// *  der stattfindenden Fixation liegt, wird die Fixation um den neuen Blickort erweitert. Die Dimension des
// *  Akzeptanzbereiches bzw. Ellipsoiden wird vom Benutzer durch das Setzen des Funktionsargumentes fAccuracyAngle
// *  vorgegeben. Dieser Winkel gibt die Genauigkeit der Messung in Abhängigkeit des verwendeten Eyetrackingsystems an und
// *  variiert horzonzal bzw. vertikal weniger als in die Tiefe. Deshalb kann auch keine Kugel als dreidimensionaler
// *  Fixationsköper angenommen werden. Der Ellipsoid wird durch den aktuellen Fixationsort, dem Genauigkeitswinkel der Messung
// *  und der Aussrichtung zu den Augen des Probanden definiert. Für die Ausrichtung wird ein Zyklpenauge als Mittelpunkt zwischen
// *  den dreidimensionalen Corneazentren des linken und rechten Auges angenommen und der Ellipsoid daran dreidimensional ausgerichtet.
// *
// *  Um Störungen in der Blickortmessungen zu berücksichtigen, wird ein einzelner Blickort, der die Abweichung in einer
// *  laufenden Fixation überschreitet, ebenfalls in die Fixation aufgenommen, sofern das nachfolgende Sample wieder
// *  innerhalb des Akzeptanzbereiches dieser Fixation liegt.
// *
// *  Sollte kein Gültiger Blickort vorliegen (z.B. während eines Blinks), wird die die Fixation verlängert, falls:
// *
// *	a) das nächste gültige Sample wieder innerhalb des Akzeptanzbereiches liegt,
// *  b) es weniger als iMinimumFixSamples aufeinanderfolgender fehlender Blickorte gibt.
// *
// *  Andernfalls wird die Fixation an Stelle der letzten gültigen bzw. guten Messung beendet.
// *
// *
// *  MASSEINHEITEN
// *  =============
// *
// *  Die Blickpositionen/Blickrichtungen können in beliebigen Einheiten angegeben werden (z.B. mm, px, rd), jedoch muss
// *  die Angabe der Filterwerte in denselben Einheiten erfolgen.
// *
// *
// *  INITIALISIERUNG DER FUNKTION
// *  ============================
// *
// *  Bevor Blickortsequenzen analysiert werden, sollte die InitFixation Funktion aufgerufen werden, um alle vorherigen,
// *  gegenwärtigen und neuen Fixationsdaten zu löschen und die Ringpuffer mit den vorherigen Blickortdaten zu
// *  initialisieren.
// *
// *
// *  PROGRAMM-HINWEIWSE
// *  ==================
// *
// *  Aus Dokumentationsgründen wird innerhalb einer Fixationssequenz die jeweiligen Fixationen als "previous",
// *  "present", und "new" bezeichnet.
// *
// *  Die present Fixation ist die derzeitig ablaufende bzw. falls eine neue Fixation startet die bereits abgeschlossene.
// *  Die previous Fixation ist die unmittelbar der gegenwärtigen vorausgegangene und die new Fixation die
// *  unmittelbar folgende Fixation. Sobald die present Fixation für beendet erklärt ist, wird die present Fixation zur
// *  previous und die new zur present. Eine neue Fixation gibt es bis jetzt noch nicht.
// *
// *--------------------------------------------------------------------------------------------------------------------------*/



var
  iPastRingIndex: Integer;
  i: Integer;
begin

  // * Stelle sicher, dass die minimale Anzahl an Samples zur Erkennung einer Fixation 3 beträgt.
  if (iMinimumFixSamples < 3) then
    iMinimumFixSamples := 3;

  // * Stelle sicher, dass die Ring-Größe groß genug für die Pufferung der Daten ist.
  Assert(iMinimumFixSamples < RING_SIZE);

  // * Erhöhe den Aufrufzähler, den Ringindex und den Ringindex-Versatz.
  Inc(iDfCallCount);
  iPastRingIndex := iCurrentRingIndex;
  Inc(iCurrentRingIndex);
  if (iCurrentRingIndex >= RING_SIZE) then
    iCurrentRingIndex := 0;
  iRingIndexDelay := iCurrentRingIndex - iMinimumFixSamples;
  if (iRingIndexDelay < 0) then
    Inc(iRingIndexDelay, RING_SIZE);

  Assert((iCurrentRingIndex >= 0) and (iCurrentRingIndex < RING_SIZE));
  Assert((iRingIndexDelay >= 0) and (iRingIndexDelay < RING_SIZE));

  // * Aktualisiere den Ringpuffer mit dem letzten Blickort.
  stRingBuf[iCurrentRingIndex].iDfCallCount := iDfCallCount;
  stRingBuf[iCurrentRingIndex].fXGaze := fXGaze;
  stRingBuf[iCurrentRingIndex].fYGaze := fYGaze;
  stRingBuf[iCurrentRingIndex].fZGaze := fZGaze;

  stRingBuf[iCurrentRingIndex].bGazeFound := bValidSample;

  // * Zunächst nehme an, dass sich das Auge bewegt.
  // * Hinweis: Diese Werte werden während der weiteren Verarbeitung dieses und der folgenden Blickorte aktualisiert.

  stRingBuf[iCurrentRingIndex].iEyeMotionState := MOVING;

  stRingBuf[iCurrentRingIndex].fXFix := -0;
  stRingBuf[iCurrentRingIndex].fYFix := -0;
  stRingBuf[iCurrentRingIndex].fZFix := -0;

  stRingBuf[iCurrentRingIndex].fXEllipsoidR:= -0;
  stRingBuf[iCurrentRingIndex].fYEllipsoidR:= -0;
  stRingBuf[iCurrentRingIndex].fZEllipsoidR:= -0;

  stRingBuf[iCurrentRingIndex].fEllipsoidYaw:= -0;
  stRingBuf[iCurrentRingIndex].fEllipsoidPitch:= -0;

  stRingBuf[iCurrentRingIndex].iFixDuration := 0;

  // * Der folgende Code erhöht die Sakkadendauer während nicht fixierender Perioden.
  // * Falls das Auge bereits im letzten Sample in Bewegung war, 
  if (stRingBuf[iPastRingIndex].iEyeMotionState = MOVING) then
  begin
    // *  erhöhe den Sakkadenzähler des letzten Samples.
    stRingBuf[iCurrentRingIndex].iSacDuration := stRingBuf[iPastRingIndex].iSacDuration + 1;
  end
  // * Andererseits, falls das Auge während des letzten Samples Fixiert hat, 
  else
  begin
    // *  setze den Sakkadenzähler auf 1, initialisiere das Sample in der Annahme, dass es sich um das erste Sample einer
    // * beginnenden Sakkade handelt.
    stRingBuf[iCurrentRingIndex].iSacDuration := 1;
  end;

  // *- - - - - - - - - - - - - Prozess für getrackte Augen - - - - - - - - - - - - - -*/

  // * A) Falls das Sample einen gültigen Blickort enthält, 
  if (bValidSample = TRUE) then
  begin
    // * A1 B) Falls eine Fixationshypothese für die gegenwärtige Fixation existiert
    if (stFix[PRES_FIX].iNEyeFoundSamples > 0) then
    begin
      // *       B1) Berechne den Abstand zwischen Blickort und gegenwärtiger Fixation und prüfe, ob sich der Blickort innerhalb des Akzeptanzbereiches liegt.
      bGazeInPresFix := IsGazeInFix(PRES_FIX, fXLeftEye, fYLeftEye, fZLeftEye, fXRightEye, fYRightEye, fZRightEye, fXGaze, fYGaze, fZGaze, fAccuracyAngleRad);

      // *       C) Falls der Blickort innerhalb des Akzeptanzbereiches liegt, 
      if bGazeInPresFix=TRUE then
      begin
        // *          C1) - Aktualisiere die Fixaionshypothese der gegenwärtigen Fixation
        // *              - prüfe, ob die gegenwärtige Fixation real ist, und falls ja,
        // *              - kennzeichne die vorangegangenen Einträge im Ringpuffer als Fixationspunkte.
        UpdateFixationHypothesis(PRES_FIX, fXLeftEye, fYLeftEye, fZLeftEye, fXRightEye, fYRightEye, fZRightEye, fXGaze, fYGaze, fZGaze, fAccuracyAngleRad, iMinimumFixSamples);
      end

      // *       Falls der neue Blickort außerhalb des Aktzeptanzbereiches liegt 
      else // if bGazeInPresFix=FALSE
      begin
        // *          C2) Erhöhe den Zähler für aufeinanderfolgende Samples außerhalb des Akzeptanzbereiches.
        Inc(iNOutsidePresEllipsoid);

        // *          D) Falls die Anzahl aufeinanderfolgender Samples außerhalb liegender Punkte das Maximum NICHT übersteigt, 
        if (iNOutsidePresEllipsoid <= iMaxOutSamples) then
        begin
          // *             D1) Nimm den Blickort in die NEUE Fixationshypothese (NEW_FIXATION) auf.
          // *             	    E)     Falls diese neue Fixationshypothese bereits gestartet wurde, 
          if (stFix[NEW_FIX].iNEyeFoundSamples > 0) then
          begin
            // *                   E1)  berechne den Blickortabstand zur neuen Fixation.
            bGazeInNewFix := IsGazeInFix(NEW_FIX, fXLeftEye, fYLeftEye, fZLeftEye, fXRightEye, fYRightEye, fZRightEye, fXGaze, fYGaze, fZGaze, fAccuracyAngleRad);

            // *                   F) Falls der neue Blickort in die neue Fixation fällt, 
            if bGazeInNewFix=TRUE then
            begin
              // *                      F1) 	- Aktualisiere die Fixationhypothese der NEW_FIXATION und
              // *                      	    - überprüfe, ob es dort genügend Samples gibt, um das Auge als fixierend zu deklarieren, und
              // *                            - falls dem so ist, kennzeichne die vorangegangenen Einträge im Ringpuffer als
              // *                              Fixationspunkte.
              UpdateFixationHypothesis(NEW_FIX, fXLeftEye, fYLeftEye, fZLeftEye, fXRightEye, fYRightEye, fZRightEye, fXGaze, fYGaze, fZGaze, fAccuracyAngleRad, iMinimumFixSamples);
            end

            // *   Falls der neue Blickort auch außerhalb der neuen Fixation liegt, 
            else // if (fNewDr > fGazeDeviationThreshold)
            begin
              // *                       F2) Setze die neue Fixation auf diesen neuen Blickort zurück.
              StartFixationHypothesisAtGazepoint(NEW_FIX, fXGaze, fYGaze, fZGaze);
            end;
          end

          // *  Falls die neue Fixationshypothese noch gar nicht gestartet ist,
          else // if (stFix[NEW_FIX].iNEyeFoundSamples == 0)
          begin
            // *                E2) Starte die neue Fixationshypothese an diesem Blickort.
            StartFixationHypothesisAtGazepoint(NEW_FIX, fXGaze, fYGaze, fZGaze);
          end;
        end

        // *   Falls zu viele aufeinanderfolgende Samples außerhalb des Akzeptanzbereiches liegen, 
        else // if (iNOutsidePresCircle > iMaxOutSamples)
        begin
          // *             D2) muss die Fixationshypothese der PRES_FIXATION als abgeschlossen oder abgelehnt deklariert werden.
          // *             G) Falls diese bestätigt werden kann, 
          if (stFix[PRES_FIX].bFixationVerified = TRUE) then
          begin
            // *                G1) - Erkläre die PRES_FIX am letzten guten Sample als abgeschlossen,
            // *                    - Erkläre die PRES_FIX zur PREV_FIX und die
            // *                    - die NEW_FIX zur PRES_FIX
            DeclarePresentFixationComplete(iMinimumFixSamples);
          end

          // *   Falls es nicht genügend gute Samples zur Bestimmung einer Fixation gibt,
          else // if (stFix[PRES_FIX].bFixationVerified == FALSE)
          begin
            // *                G2) Verwerfe die Fixationshypothese der PRES_FIX, in dem diese durch die neue Fixation NEW_FIX
            // *                    ausgetauscht wird, die zu diesem Zeitpunkt existiert, oder auch nicht existiert.
            MoveNewFixToPresFix();
          end;

          // *             H) Falls es eine Fixationshypothese für PRES_FIX gibt, 
          if (stFix[PRES_FIX].iNEyeFoundSamples > 0) then
          begin
            // *                H1) Berechne den Abstand des Blickortes zur jetzt neuen PRES_FIXATION (kurz vorher noch NEW_FIX).
            bGazeInPresFix := IsGazeInFix(PRES_FIX, fXLeftEye, fYLeftEye, fZLeftEye, fXRightEye, fYRightEye, fZRightEye, fXGaze, fYGaze, fZGaze, fAccuracyAngleRad);

            // *                I) Falls der Blickort innerhalb des Akzeptanzbereiches der jetzt neuen  PRES_FIX liegt, 
            if bGazeInPresFix = TRUE then
            begin
              // *                   I1) - Aktualisiere PRES_FIX,
              // *                        - überprüfe, ob es dort genügend Samples gibt, um das Auge als fixierend zu deklarieren, und
              // *                        - falls dem so ist, kennzeichne die vorangegangenen Einträge im Ringpuffer als
              // *                          Fixationspunkte.
              UpdateFixationHypothesis(PRES_FIX, fXLeftEye, fYLeftEye, fZLeftEye, fXRightEye, fYRightEye, fZRightEye, fXGaze, fYGaze, fZGaze, fAccuracyAngleRad, iMinimumFixSamples);
            end

            // * Andernfalls, falls der Blickort außerhalb des Akzeptanzbereiches liegt, 
            else // if (fPresDr > fGazeDeviationThreshold)
            begin
              // *                   I2) Starte eine neue Fixationshypothese für NEW_FIX an diesem Blickort.
              StartFixationHypothesisAtGazepoint(NEW_FIX, fXGaze, fYGaze, fZGaze);
            end;
          end

          // * Andernfalls, falls es keine Fixationshypothese für PRES_FIX gibt, 
          else // if (stFix[PRES_FIX].iNEyeFoundSamples == 0)
          begin
            // *                H2) Starte eine neue Fixationshypothese für  PRES_FIX an diesem Blickort.
            StartFixationHypothesisAtGazepoint(PRES_FIX, fXGaze, fYGaze, fZGaze);
          end;
        end;
      end;
    end

    // * Andernfalls, falls es keine Fixationshypothese für PRES_FIX gibt, 
    else // if (stFix[PRES_FIX].iNEyeFoundSamples == 0)
    begin
      // *       B2) Starte eine neue Fixationshypothese für  PRES_FIX an diesem Blickort und lösche die für NEW_FIX
      StartFixationHypothesisAtGazepoint(PRES_FIX, fXGaze, fYGaze, fZGaze);
    end;
  end

  // *- - - - - - - - - - - - - Prozess für NICHT getrackte Augen  - - - - - - - - - - - - -*/

  // * Andernfalls, wenn das Sample keinen gültigen Blickort aufweist, 
  else // if (bGazepointFound == FALSE)
  begin
    // *    A2 J) Falls der Ausfall noch innerhalb der zulässingen Grenzen liegt, z.B. innerhalb des Zeitfenster für maximal
    // *          ungültige Samples liegt, 
    if (iDfCallCount - stFix[PRES_FIX].iEndCount <= iMaxMissedSamples) then
    begin
      // *       J1)  brauch hier NICHTS unternommen werden.
    end

    // *    Andernfalls, wenn die Ausfalllücke zum letzten guten Sample zu groß ist, 
    else // if (iDFCallCount - stFix[PRES_FIX].iEndCount > iMaxMissedSamples)
    begin
      // *       J2)  muss die Fixationshypothese für PRES_FIX abgelehnt oder für abgeschlossen erklärt werden:
      // *       K) Falls die Fixationshypothese bestätigt werden kann, 
      if (stFix[PRES_FIX].bFixationVerified = TRUE) then
      begin
        // *          K1) - Erkläre die PRES_FIX am letzten guten Sample als abgeschlossen,
        // *              - Erkläre die PRES_FIX zur PREV_FIX und die
        // *              - die NEW_FIX zur PRES_FIX
        DeclarePresentFixationComplete(iMinimumFixSamples);
      end

      // * Andernfalls, wenn die Fixationshypothese für PRES_FIX nicht bestätig werden kann, 
      else // if (stFix[PRES_FIX].bFixationVerified == FALSE)
      begin
        // *          K2) Verwerfe die Fixationshypothese der PRES_FIX, in dem diese durch die neue Fixation NEW_FIX
       // *               ausgetauscht wird, die zu diesem Zeitpunkt existiert, oder auch nicht existiert.
        MoveNewFixToPresFix();
      end;
    end;
  end;

  // *---------------------------- Pass Data Back ------------------------------*/

  Assert((iRingIndexDelay >= 0) and (iRingIndexDelay < RING_SIZE));

  // * Gib die verzögerten Blickortdaten, mit den entsprechenden Sakkaden-/Fixationsinformationen an die aufrufende
  // * Funktion zurück (werden als Output-Parameter zurückgegeben).

  pbValidSampleDelayed := stRingBuf[iRingIndexDelay].bGazeFound;

  pfXGazeDelayed := stRingBuf[iRingIndexDelay].fXGaze;
  pfYGazeDelayed := stRingBuf[iRingIndexDelay].fYGaze;
  pfZGazeDelayed := stRingBuf[iRingIndexDelay].fZGaze;

  pfXFixDelayed := stRingBuf[iRingIndexDelay].fXFix;
  pfYFixDelayed := stRingBuf[iRingIndexDelay].fYFix;
  pfZFixDelayed := stRingBuf[iRingIndexDelay].fZFix;

  pfXEllipsoidRDelayed := stRingBuf[iRingIndexDelay].fXEllipsoidR;
  pfYEllipsoidRDelayed := stRingBuf[iRingIndexDelay].fYEllipsoidR;
  pfZEllipsoidRDelayed := stRingBuf[iRingIndexDelay].fZEllipsoidR;

  pfEllipsoidYawDelayed := stRingBuf[iRingIndexDelay].fEllipsoidYaw;
  pfEllipsoidPitchDelayed := stringBuf[iRingIndexDelay].fEllipsoidPitch;

  piSacDurationDelayed := stRingBuf[iRingIndexDelay].iSacDuration;
  piFixDurationDelayed := stRingBuf[iRingIndexDelay].iFixDuration;

  // * Rückgabewert der Funktion als Bewegungs/Fixationsstatus (Eye Motion State) des VERZÖGERTEN Blickortes.
  Result := stRingBuf[iRingIndexDelay].iEyeMotionState;

  ///////////////////////////////////////////////////////////////////////////////
  ///
  /// Global Output Parameters
  ///

  for i := 0 to RING_SIZE do
    gb_stRingBuf[i]:=stRingBuf[i];

  for i := 0 to 2 do
    gb_stFix[i]:=stFix[i];


end;




procedure TFixFuncClass3dCalcByEllipsoid.TestPresentFixationHypothesis(iMinimumFixSamples: Integer);

// * Diese Funktion testet, ob es genügend Samples in der gegenwärtigen Fixationshypothese gibt, um das Auge als
// * 'fixierend zu deklarieren. Falls eine Fixation läuft, aktualisiert die Funktion die entsprechenden momentanen und
// * früheren Ringpuffereinträge, die zur Fixation gehören.

var
  iEarlierPointOffset: Integer; 	// * Index-Offset zum jetzigen Ringpufferindex
  iDumRingIndex: Integer; 		    // * Dummy Ringindex

 // * Falls es genügend gültige Samples in der Fixationshypothese für PRES_FIX gibt, um eine reale Fixation zu bestimmen,
 // * ...
begin
  if (stFix[PRES_FIX].iNEyeFoundSamples >= iMinimumFixSamples) then
  begin
    // *    Deklariere das Auge als fixierend. Gehe rückwärts durch die letzten iMinimumFixSamples Einträge des
    // *    Ringpuffers inklusive des aktuellen Punktes, 
    for iEarlierPointOffset := 0 to iMinimumFixSamples - 1 do
    begin
      // *    Berechne den Ringindex des früheren Zeitpunktes
      iDumRingIndex := iCurrentRingIndex - iEarlierPointOffset;
      if (iDumRingIndex < 0) then
        Inc(iDumRingIndex, RING_SIZE);

      Assert((iDumRingIndex >= 0) and (iDumRingIndex < RING_SIZE));

      // *       Markiere den Punkt als fixierend bzw. innerhalb der Fixation.
      stRingBuf[iDumRingIndex].iEyeMotionState := FIXATING;
      stRingBuf[iDumRingIndex].fXFix := stFix[PRES_FIX].fX;
      stRingBuf[iDumRingIndex].fYFix := stFix[PRES_FIX].fY;
      stRingBuf[iDumRingIndex].fZFix := stFix[PRES_FIX].fZ;

      // *       Setze den Ringpuffereintrag für die Sakkadendauer.
      // *       Hinweis: Diese ist für alle Punkte identisch.
      stRingBuf[iDumRingIndex].iSacDuration := stFix[PRES_FIX].iStartCount - stFix[PREV_FIX].iEndCount - 1;

      // *       Setze den Ringpuffereintrag für die Fixationsdauer, z.B. die Zeit zwischen Start der gegenwärtigen Fixation und
      // *       die durch den Ringindex angegebene Zeit.
      // *       Hinweis: Die Fixationsdauer verringert sich bei früher erfassten Punkten innerhalb der Fixation.
      stRingBuf[iDumRingIndex].iFixDuration := stFix[PRES_FIX].iEndCount - iEarlierPointOffset - stFix[PRES_FIX].iStartCount + 1;

    end;

  end;
end;

end.



